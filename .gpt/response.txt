&&& FILE: ./backend/main.py
&&& CONTENT:
# ./backend/main.py
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from database import async_session, init_db
from models import Building
from sqlalchemy.future import select
from geoalchemy2.functions import ST_AsGeoJSON, ST_Intersects, ST_GeomFromText
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import json
import math

app = FastAPI()

# Configure CORS
origins = [
    "http://localhost:8080",  # Frontend origin
    # Add other origins if needed
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,  # Allowed origins
    allow_credentials=True,
    allow_methods=["*"],    # Allow all HTTP methods
    allow_headers=["*"],    # Allow all headers
)

@app.on_event("startup")
async def on_startup():
    await init_db()

async def get_db():
    async with async_session() as session:
        yield session

@app.get("/")
async def read_root():
    return {"message": "Hello World"}

@app.get("/buildings/nuremberg")
async def get_buildings_nuremberg(db: AsyncSession = Depends(get_db)):
    """
    Get buildings within the predefined boundary of Nürnberg.
    """
    try:
        # Define the bounding box for Nürnberg (approximate coordinates)
        nuremberg_bbox = 'POLYGON((11.0 49.4, 11.2 49.4, 11.2 49.6, 11.0 49.6, 11.0 49.4))'

        # Convert WKT polygon to geometry
        geometry = ST_GeomFromText(nuremberg_bbox, 4326)

        # Build the query
        query = select(
            Building.ogc_fid,
            Building.name,
            ST_AsGeoJSON(Building.geometry).label('geometry')
        ).where(
            ST_Intersects(Building.geometry, geometry)
        )

        # Execute the query
        result = await db.execute(query)
        buildings = result.fetchall()

        # Construct GeoJSON response
        features = []
        for building in buildings:
            feature = {
                "type": "Feature",
                "geometry": json.loads(building.geometry),
                "properties": {
                    "id": building.ogc_fid,
                    "name": building.name
                }
            }
            features.append(feature)

        geojson = {
            "type": "FeatureCollection",
            "features": features
        }

        return geojson

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Utility function to calculate tile bounding box
def tile_bbox(x: int, y: int, z: int):
    """
    Calculate the bounding box for a given tile in EPSG:4326.

    Args:
        x (int): Tile X coordinate.
        y (int): Tile Y coordinate.
        z (int): Zoom level.

    Returns:
        tuple: (min_lon, min_lat, max_lon, max_lat)
    """
    n = 2.0 ** z
    lon_deg_min = x / n * 360.0 - 180.0
    lat_rad_min = math.atan(math.sinh(math.pi * (1 - 2 * y / n)))
    lat_deg_min = math.degrees(lat_rad_min)

    lon_deg_max = (x + 1) / n * 360.0 - 180.0
    lat_rad_max = math.atan(math.sinh(math.pi * (1 - 2 * (y + 1) / n)))
    lat_deg_max = math.degrees(lat_rad_max)

    return (lon_deg_min, lat_deg_min, lon_deg_max, lat_deg_max)

@app.get("/buildings/tiles/{z}/{x}/{y}")
async def get_buildings_tile(z: int, x: int, y: int, db: AsyncSession = Depends(get_db)):
    """
    Get buildings within the bounding box of a specific tile.
    """
    try:
        # Calculate bounding box for the tile
        bbox = tile_bbox(x, y, z)
        bbox_wkt = f'POLYGON(({bbox[0]} {bbox[1]}, {bbox[0]} {bbox[3]}, {bbox[2]} {bbox[3]}, {bbox[2]} {bbox[1]}, {bbox[0]} {bbox[1]}))'

        # Query buildings within the bounding box
        query = select(
            Building.ogc_fid,
            Building.name,
            ST_AsGeoJSON(Building.geometry).label('geometry')
        ).where(
            ST_Intersects(Building.geometry, ST_GeomFromText(bbox_wkt, 4326))
        )

        result = await db.execute(query)
        buildings = result.fetchall()

        # Construct GeoJSON FeatureCollection
        features = []
        for building in buildings:
            geometry = json.loads(building.geometry)
            feature = {
                "type": "Feature",
                "geometry": geometry,
                "properties": {
                    "id": building.ogc_fid,
                    "name": building.name
                }
            }
            features.append(feature)

        geojson = {
            "type": "FeatureCollection",
            "features": features
        }

        return JSONResponse(content=geojson)

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

&&& FILE: ./backend/models.py
&&& CONTENT:
# ./backend/models.py
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from geoalchemy2 import Geometry

Base = declarative_base()

class Building(Base):
    __tablename__ = 'building'

    ogc_fid = Column(Integer, primary_key=True)
    name = Column(String)
    geometry = Column(Geometry('MULTIPOLYGONZ', srid=4326))  # Adjust geometry type as needed

&&& FILE: ./backend/database.py
&&& CONTENT:
# ./backend/database.py
import os
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from models import Base

DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql+asyncpg://postgres:barcelona@localhost:5432/easyopendata_database')

engine = create_async_engine(DATABASE_URL, echo=True, pool_size=20, max_overflow=0)
async_session = sessionmaker(
    bind=engine, class_=AsyncSession, expire_on_commit=False
)

# Function to create tables
async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

&&& FILE: ./backend/data_ingest/ingest_baden_wuerttemberg.py
&&& CONTENT:
# ./backend/data_ingest/ingest_baden_wuerttemberg.py
import os
import glob
import subprocess

DATA_DIR = 'backend/data_local/baden_wuerttemberg'
DATABASE_URL = os.getenv('DATABASE_URL', 'PG:dbname=easyopendata_database user=postgres password=barcelona')

def ingest_gml_files():
    gml_files = glob.glob(os.path.join(DATA_DIR, '*.gml'))
    for gml_file in gml_files:
        cmd = [
            'ogr2ogr',
            '-f', 'PostgreSQL',
            '-overwrite',
            '-progress',
            DATABASE_URL,
            gml_file
        ]
        subprocess.run(cmd)

if __name__ == '__main__':
    ingest_gml_files()

&&& FILE: ./backend/data_ingest/ingest_bayern.py
&&& CONTENT:
# ./backend/data_ingest/ingest_bayern.py
import os
import glob
import subprocess

DATA_DIR = 'backend/data_local/bayern'
DATABASE_URL = os.getenv('DATABASE_URL', 'PG:dbname=easyopendata_database user=postgres password=barcelona')

def ingest_gml_files():
    gml_files = glob.glob(os.path.join(DATA_DIR, '*.gml'))
    for gml_file in gml_files:
        cmd = [
            'ogr2ogr',
            '-f', 'PostgreSQL',
            '-overwrite',
            '-progress',
            '-lco', 'GEOMETRY_NAME=geometry',
            '-skipfailures',
            '-nlt', 'CONVERT_TO_LINEAR',
            '-nlt', 'MULTIPOLYGON',
            '-s_srs', 'EPSG:25832',
            '-t_srs', 'EPSG:4326',
            DATABASE_URL,
            gml_file
        ]
        subprocess.run(cmd)

if __name__ == '__main__':
    ingest_gml_files()

&&& FILE: ./backend/data_ingest/ingest_thuringia.py
&&& CONTENT:
# ./backend/data_ingest/ingest_thuringia.py
import os
import glob
import subprocess

DATA_DIR = 'backend/data_local/thuringia'
DATABASE_URL = os.getenv('DATABASE_URL', 'PG:dbname=easyopendata_database user=postgres password=barcelona')

def ingest_gml_files():
    gml_files = glob.glob(os.path.join(DATA_DIR, '*.gml'))
    for gml_file in gml_files:
        cmd = [
            'ogr2ogr',
            '-f', 'PostgreSQL',
            '-overwrite',
            '-progress',
            '-lco', 'GEOMETRY_NAME=geometry',
            '-skipfailures',
            '-nlt', 'CONVERT_TO_LINEAR',
            '-nlt', 'MULTIPOLYGON',
            '-s_srs', 'EPSG:25832',
            '-t_srs', 'EPSG:4326',
            DATABASE_URL,
            gml_file
        ]
        subprocess.run(cmd)

if __name__ == '__main__':
    ingest_gml_files()

&&& FILE: ./backend/data_ingest/transform_gml.py
&&& CONTENT:
# ./backend/data_ingest/transform_gml.py
#!/usr/bin/env python3
"""
transform_gml.py

A script to transform a CityGML file by embedding polygon geometries directly within
lod2Solid's surfaceMember elements, removing external xlink references.

Usage:
    python transform_gml.py input.gml output.gml

### python .\transform_gml.py .\..\data_local\bayern\raw\650_5478.gml .\..\data_local\bayern\650_5478_trs.gml
"""

import sys
import os
from lxml import etree

def get_all_namespaces(gml_tree):
    """
    Extracts all namespaces from the GML tree and assigns a unique prefix to the default namespace.

    Args:
        gml_tree (etree.ElementTree): Parsed GML tree.

    Returns:
        dict: Namespace prefix to URI mapping.
    """
    nsmap = gml_tree.getroot().nsmap.copy()
    # Handle default namespace (None key)
    if None in nsmap:
        nsmap['default'] = nsmap.pop(None)
    # Ensure 'xlink' is included
    if 'xlink' not in nsmap:
        # Attempt to find the xlink namespace
        for prefix, uri in nsmap.items():
            if uri == 'http://www.w3.org/1999/xlink':
                nsmap['xlink'] = uri
                break
        else:
            # If not found, add it manually
            nsmap['xlink'] = 'http://www.w3.org/1999/xlink'
    return nsmap

def transform_gml(input_file, output_file):
    """
    Transforms the input GML file by embedding polygons into surfaceMember elements.

    Args:
        input_file (str): Path to the input GML file.
        output_file (str): Path to the output transformed GML file.
    """
    # Parse the GML file
    print(f"Parsing input GML file: {input_file}")
    parser = etree.XMLParser(remove_blank_text=True)
    tree = etree.parse(input_file, parser)
    root = tree.getroot()

    # Extract all namespaces
    namespaces = get_all_namespaces(tree)
    print("Namespaces detected:")
    for prefix, uri in namespaces.items():
        print(f"  Prefix: '{prefix}' => URI: '{uri}'")

    # Build a dictionary of gml:id to Polygon elements for quick lookup
    print("Indexing all <gml:Polygon> elements by gml:id...")
    polygon_dict = {}
    for polygon in root.xpath('.//gml:Polygon', namespaces=namespaces):
        polygon_id = polygon.get('{http://www.opengis.net/gml}id')
        if polygon_id:
            polygon_dict[polygon_id] = polygon
    print(f"Indexed {len(polygon_dict)} polygons.")

    # Find all <gml:surfaceMember> elements with xlink:href
    print("Finding all <gml:surfaceMember> elements with xlink:href...")
    surface_members = root.xpath('.//gml:surfaceMember[@xlink:href]', namespaces=namespaces)
    print(f"Found {len(surface_members)} <gml:surfaceMember> elements with xlink:href.")

    for sm in surface_members:
        href = sm.get('{http://www.w3.org/1999/xlink}href')
        if not href:
            continue
        # Extract the referenced polygon ID (remove the '#' prefix)
        polygon_id = href.lstrip('#')
        print(f"Processing surfaceMember referencing Polygon ID: {polygon_id}")
        polygon = polygon_dict.get(polygon_id)
        if not polygon:
            print(f"Warning: Polygon with gml:id='{polygon_id}' not found. Skipping.")
            continue
        # Deep copy the polygon element
        polygon_copy = etree.fromstring(etree.tostring(polygon))
        # Remove any existing 'gml:id' to avoid duplicate IDs
        polygon_copy.attrib.pop('{http://www.opengis.net/gml}id', None)
        # Replace the surfaceMember's xlink:href attribute with the actual Polygon
        sm.clear()  # Remove existing children and attributes
        sm.append(polygon_copy)
        print(f"Embedded Polygon ID: {polygon_id} into surfaceMember.")

    # Optionally, remove standalone <gml:Polygon> elements that were referenced
    print("Removing standalone <gml:Polygon> elements that were referenced...")
    removed_count = 0
    # for polygon_id in polygon_dict.keys():
    #     # Find and remove the standalone polygon
    #     polygons_to_remove = root.xpath(f'.//gml:Polygon[@gml:id="{polygon_id}"]', namespaces=namespaces)
    #     for polygon in polygons_to_remove:
    #         parent = polygon.getparent()
    #         if parent is not None:
    #             parent.remove(polygon)
    #             removed_count += 1
    #             print(f"Removed standalone Polygon ID: {polygon_id}.")
    # print(f"Removed {removed_count} standalone polygons.")

    # Write the transformed GML to the output file
    print(f"Writing transformed GML to: {output_file}")
    tree.write(output_file, pretty_print=True, xml_declaration=True, encoding='UTF-8')
    print("Transformation complete.")

def main():
    if len(sys.argv) != 3:
        print("Usage: python transform_gml.py input.gml output.gml")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]

    if not os.path.isfile(input_file):
        print(f"Error: Input file '{input_file}' does not exist.")
        sys.exit(1)

    try:
        transform_gml(input_file, output_file)
    except etree.XMLSyntaxError as e:
        print(f"XML Syntax Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred during transformation: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

&&& FILE: ./frontend/index.html
&&& CONTENT:
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>EasyOpenData - Nürnberg 2.5D Buildings</title>
    <!-- Leaflet CSS -->
    <link 
        rel="stylesheet" 
        href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" 
    />
    <style>
        html, body, #map {
            width: 100%; 
            height: 100%; 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            background-color: #2e2e2e; /* Optional: Dark background */
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <!-- Leaflet.PolyExtrusion JS -->
    <script src="vendor/leaflet.polyextrusion/leaflet.polyextrusion.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            console.log("DOM fully loaded and parsed");

            // Initialize the Leaflet map
            const map = L.map('map').setView([49.4497, 11.0683], 14); // Centered on Nürnberg
            console.log("Leaflet map initialized");

            // Add CartoDB Dark Matter tile layer
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
            console.log("Dark Matter tile layer added to map");

            // Layer Group to manage building extrusions
            const buildingsLayerGroup = L.layerGroup().addTo(map);

            // Debounce function to limit the rate of tile loading
            function debounce(func, delay) {
                let debounceTimer;
                return function() {
                    const context = this;
                    const args = arguments;
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => func.apply(context, args), delay);
                }
            }

            // Convert longitude to tile number
            function long2tile(lon, lat, zoom) {
                const n = Math.pow(2, zoom);
                const xtile = Math.floor((lon + 180) / 360 * n);
                const ytile = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);
                return {x: xtile, y: ytile};
            }

            // Fetch and render building data for visible tiles
            async function loadBuildings() {
                const bounds = map.getBounds();
                const zoom = map.getZoom();

                const nwTile = long2tile(bounds.getWest(), bounds.getNorth(), zoom);
                const seTile = long2tile(bounds.getEast(), bounds.getSouth(), zoom);

                for (let x = nwTile.x; x <= seTile.x; x++) {
                    for (let y = nwTile.y; y <= seTile.y; y++) {
                        fetchTileData(x, y, zoom);
                    }
                }
            }

            // Client-side caching to avoid redundant requests
            const fetchedTiles = {};

            // Fetch building data for a specific tile
            async function fetchTileData(x, y, z) {
                const tileKey = `${z}/${x}/${y}`;
                if (fetchedTiles[tileKey]) return; // Skip if already fetched

                fetchedTiles[tileKey] = true; // Mark as fetched

                const url = `http://localhost:8000/buildings/tiles/${z}/${x}/${y}`;
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();

                    // Create PolyExtrusion layer
                    const extrusionLayer = L.polyExtrusion(data, {
                        color: 'orange',
                        weight: 1,
                        opacity: 0.6,
                        heightProperty: 'height', // Ensure 'height' is provided in GeoJSON
                        onEachFeature: function(feature, layer) {
                            if (feature.properties && feature.properties.name) {
                                layer.bindPopup(`<strong>${feature.properties.name}</strong><br>Height: ${feature.properties.height} m`);
                            }
                        },
                        style: function(feature) {
                            const height = feature.properties.height || 30;
                            let fillColor = 'yellow';

                            if (height > 100) {
                                fillColor = 'red';
                            } else if (height > 50) {
                                fillColor = 'orange';
                            } else {
                                fillColor = 'yellow';
                            }

                            return {
                                color: 'black',
                                weight: 1,
                                fillColor: fillColor,
                                fillOpacity: 0.6
                            };
                        }
                    });

                    buildingsLayerGroup.addLayer(extrusionLayer);
                    console.log(`Loaded tile ${tileKey}`);
                } catch (error) {
                    console.error(`Error fetching tile ${tileKey}:`, error);
                }
            }

            // Initial load
            loadBuildings();

            // Load buildings on map move end with debounce
            map.on('moveend', debounce(function() {
                buildingsLayerGroup.clearLayers(); // Clear existing layers
                loadBuildings(); // Load new visible tiles
            }, 500)); // Adjust debounce delay as needed
        });
    </script>
</body>
</html>

&&& FILE: ./frontend/vendor/leaflet.polyextrusion/leaflet.polyextrusion.js
&&& CONTENT:
# ./frontend/vendor/leaflet.polyextrusion/leaflet.polyextrusion.js
/* 
Leaflet.PolyExtrusion plugin script
Ensure you have this file downloaded from the Leaflet.PolyExtrusion repository
and placed in the specified path.
*/

(function (factory, window) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['leaflet'], factory);
    } else if (typeof module !== 'undefined') {
        // Node/CommonJS
        module.exports = factory(require('leaflet'));
    } else {
        // Browser globals
        if (typeof window.L === 'undefined') {
            throw 'Leaflet.PolyExtrusion requires Leaflet to be loaded first.';
        }
        factory(window.L);
    }
}(function (L) {
    L.PolyExtrusion = L.GeoJSON.extend({
        options: {
            color: 'orange',
            weight: 1,
            opacity: 0.6,
            heightProperty: 'height', // Property name for extrusion height
            fillColor: 'yellow',
            fillOpacity: 0.6
        },

        initialize: function (geojson, options) {
            L.setOptions(this, options);
            L.GeoJSON.prototype.initialize.call(this, geojson, options);
        },

        onEachFeature: function (feature, layer) {
            if (feature.properties && feature.properties[this.options.heightProperty]) {
                const height = feature.properties[this.options.heightProperty];
                layer.options.height = height;
                // Custom rendering logic can be added here
            }

            if (this.options.onEachFeature) {
                this.options.onEachFeature(feature, layer);
            }
        },

        style: function (feature) {
            return {
                color: feature.properties.color || this.options.color,
                weight: feature.properties.weight || this.options.weight,
                opacity: feature.properties.opacity || this.options.opacity,
                fillColor: feature.properties.fillColor || this.options.fillColor,
                fillOpacity: feature.properties.fillOpacity || this.options.fillOpacity
            };
        },

        // Override the _addPath method to handle extrusion
        _addPath: function (layer) {
            // Implement extrusion rendering logic here
            // This is a placeholder; actual 3D extrusion would require WebGL or Canvas rendering
            L.GeoJSON.prototype._addPath.call(this, layer);
        }
    });

    L.polyExtrusion = function (geojson, options) {
        return new L.PolyExtrusion(geojson, options);
    };
}, window));

&&& FILE: ./frontend/vendor/leaflet.polyextrusion/leaflet.polyextrusion.css
&&& CONTENT:
/* ./frontend/vendor/leaflet.polyextrusion/leaflet.polyextrusion.css */
/* Add any necessary styles for PolyExtrusion here */
/* Currently empty as extrusion is handled via JavaScript and Leaflet layers */
