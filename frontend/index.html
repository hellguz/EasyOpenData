<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>EasyOpenData - Nürnberg Buildings</title>
    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
    />
    <style>
      html,
      body,
      #map {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #2e2e2e; /* Optional: Dark background */
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM fully loaded and parsed");

        // Initialize the Leaflet map
        const map = L.map("map").setView([49.4497, 11.0683], 14); // Centered on Nürnberg
        console.log("Leaflet map initialized");

        // Add CartoDB Dark Matter tile layer
        L.tileLayer(
          "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
          {
            attribution:
              '&copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: "abcd",
            maxZoom: 19,
          }
        ).addTo(map);
        console.log("Dark Matter tile layer added to map");

        // Layer Group to manage building layers
        const buildingsLayerGroup = L.layerGroup().addTo(map);

        // Debounce function to limit the rate of tile loading
        function debounce(func, delay) {
          let debounceTimer;
          return function () {
            const context = this;
            const args = arguments;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => func.apply(context, args), delay);
          };
        }

        // Convert longitude to tile number
        function long2tile(lon, lat, zoom) {
          const n = Math.pow(2, zoom);
          const xtile = Math.floor(((lon + 180) / 360) * n);
          const ytile = Math.floor(
            ((1 -
              Math.log(
                Math.tan((lat * Math.PI) / 180) +
                  1 / Math.cos((lat * Math.PI) / 180)
              ) /
                Math.PI) /
              2) *
              n
          );
          return { x: xtile, y: ytile };
        }

        // Fetch and render building data for visible tiles
        async function loadBuildings() {
          const bounds = map.getBounds();
          const zoom = map.getZoom();

          // Determine tile range for current bounds
          const nwTile = long2tile(bounds.getWest(), bounds.getNorth(), zoom);
          const seTile = long2tile(bounds.getEast(), bounds.getSouth(), zoom);

          for (let x = nwTile.x; x <= seTile.x; x++) {
            for (let y = nwTile.y; y <= seTile.y; y++) {
              await fetchTileData(x, y, zoom); // Fetch only missing tiles
            }
          }
        }

        const fetchedTiles = {}; // Cache to track loaded tiles

        async function fetchTileData(x, y, z) {
          const tileKey = `${z}/${x}/${y}`;
          if (fetchedTiles[tileKey]) return; // Skip if already fetched

          fetchedTiles[tileKey] = true; // Mark tile as fetched

          const url = `http://localhost:8000/buildings/tiles/${z}/${x}/${y}`;
          try {
            const response = await fetch(url);
            if (!response.ok)
              throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();

            // Add GeoJSON data to the map
            const geojsonLayer = L.geoJSON(data, {
              style: function (feature) {
                return {
                  color: "yellow",
                  weight: 1,
                  fillColor: "yellow",
                  fillOpacity: 0.2,
                };
              },
              onEachFeature: function (feature, layer) {
                if (feature.properties && feature.properties.name) {
                  layer.bindPopup(
                    `<strong>${feature.properties.name}</strong><br>Height: ${feature.properties.height} m`
                  );
                }
              },
            });

            buildingsLayerGroup.addLayer(geojsonLayer);
            console.log(`Loaded tile ${tileKey}`);
          } catch (error) {
            console.error(`Error fetching tile ${tileKey}:`, error);
            fetchedTiles[tileKey] = false; // Allow retry if the fetch failed
          }
        }

        // Initial load
        loadBuildings();

        // Load buildings on map move end with debounce
        map.on(
          "moveend",
          debounce(function () {
            // buildingsLayerGroup.clearLayers(); // Clear existing layers
            loadBuildings(); // Load new visible tiles
          }, 300)
        ); // Adjust debounce delay as needed
      });
    </script>
  </body>
</html>
