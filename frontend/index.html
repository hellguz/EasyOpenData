<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>EasyOpenData - NÃ¼rnberg Buildings</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
    />
    <style>
      html,
      body,
      #map {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #2e2e2e;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM fully loaded and parsed");

        const map = L.map("map").setView([49.4497, 11.0683], 18);
        console.log("Leaflet map initialized");

        L.tileLayer(
          "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
          {
            attribution:
              '&copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: "abcd",
            maxZoom: 19,
          }
        ).addTo(map);
        console.log("Dark Matter tile layer added to map");

        const buildingsLayerGroup = L.layerGroup().addTo(map);
        console.log("Building layer group added");

        let currentZoom = map.getZoom();
        const fetchedTiles = {};
        const tileQueue = [];
        let isProcessingQueue = false;

        function debounce(func, delay) {
          let debounceTimer;
          return function () {
            const context = this;
            const args = arguments;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => func.apply(context, args), delay);
          };
        }

        function long2tile(lon, lat, zoom) {
          const n = Math.pow(2, zoom);
          const xtile = Math.floor(((lon + 180) / 360) * n);
          const ytile = Math.floor(
            ((1 -
              Math.log(
                Math.tan((lat * Math.PI) / 180) +
                  1 / Math.cos((lat * Math.PI) / 180)
              ) /
                Math.PI) /
              2) *
              n
          );
          return { x: xtile, y: ytile };
        }

        function loadBuildings() {
          console.log("Loading buildings...");
          const bounds = map.getBounds();
          const zoom = map.getZoom();
          console.log(`Current map bounds: ${bounds.toBBoxString()}`);
          console.log(`Current zoom level: ${zoom}`);

          const nwTile = long2tile(bounds.getWest(), bounds.getNorth(), zoom);
          const seTile = long2tile(bounds.getEast(), bounds.getSouth(), zoom);
          console.log(
            `Tile range: NW (${nwTile.x}, ${nwTile.y}) to SE (${seTile.x}, ${seTile.y})`
          );

          for (let x = nwTile.x; x <= seTile.x; x++) {
            for (let y = nwTile.y; y <= seTile.y; y++) {
              const tileKey = `${zoom}/${x}/${y}`;
              if (!fetchedTiles[tileKey]) {
                console.log(`Queueing tile ${tileKey}`);
                tileQueue.push({ x, y, zoom });
              }
            }
          }

          if (!isProcessingQueue) {
            processQueue();
          }
        }

        function processQueue() {
          if (tileQueue.length === 0) {
            isProcessingQueue = false;
            console.log("Tile queue processing completed");
            return;
          }

          isProcessingQueue = true;
          const { x, y, zoom } = tileQueue.shift();
          console.log(`Processing tile: ${zoom}/${x}/${y}`);
          fetchTileData(x, y, zoom).then(() => {
            setTimeout(processQueue, 50); // Add a small delay between tile loads
          });
        }

        async function fetchTileData(x, y, z) {
          const tileKey = `${z}/${x}/${y}`;
          if (fetchedTiles[tileKey]) {
            console.log(`Tile ${tileKey} already fetched`);
            return;
          }

          fetchedTiles[tileKey] = true;
          const url = `http://localhost:8000/buildings/tiles/${z}/${x}/${y}`;
          console.log(`Fetching tile data from ${url}`);

          try {
            const response = await fetch(url);
            if (!response.ok)
              throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();

            const geojsonLayer = L.geoJSON(data, {
              style: { color: "yellow", weight: 1 },
            });
            geojsonLayer.tileKey = tileKey;
            buildingsLayerGroup.addLayer(geojsonLayer);
            console.log(`Tile ${tileKey} loaded and added to map`);
          } catch (error) {
            console.error(`Error fetching tile ${tileKey}:`, error);
            fetchedTiles[tileKey] = false;
          }
        }

        function clearAllTiles() {
          console.log("Clearing all tiles...");
          buildingsLayerGroup.clearLayers();
          Object.keys(fetchedTiles).forEach((key) => {
            fetchedTiles[key] = false;
          });
          tileQueue.length = 0; // Clear the queue
        }

        function removeOutdatedTiles() {
          console.log("Removing outdated tiles...");
          try {
            const bounds = map.getBounds();
            console.log(`Current viewport bounds: ${bounds.toBBoxString()}`);
            const layersToRemove = [];

            buildingsLayerGroup.eachLayer((layer) => {
              if (layer.getBounds && typeof layer.getBounds === "function") {
                const layerBounds = layer.getBounds();
                if (!bounds.intersects(layerBounds)) {
                  layersToRemove.push(layer);
                }
              } else {
                console.warn("Layer without getBounds method:", layer);
              }
            });

            layersToRemove.forEach((layer) => {
              if (layer.tileKey) {
                console.log(`Removing tile ${layer.tileKey}`);
                buildingsLayerGroup.removeLayer(layer);
                fetchedTiles[layer.tileKey] = false;
              } else {
                console.warn("Layer without tileKey property:", layer);
              }
            });
          } catch (error) {
            console.error("Error in removeOutdatedTiles:", error);
          }
        }

        loadBuildings();

        map.on(
          "moveend",
          debounce(() => {
            console.log("Map moveend event triggered");
            removeOutdatedTiles();
            loadBuildings();
          }, 300)
        );

        map.on(
          "zoomend",
          debounce(() => {
            const newZoom = map.getZoom();
            console.log(`Zoom changed from ${currentZoom} to ${newZoom}`);
            if (newZoom !== currentZoom) {
              clearAllTiles();
              currentZoom = newZoom;
              loadBuildings();
            }
          }, 300)
        );
      });
    </script>
  </body>
</html>
